
# 内存管理
1. 内存： 由可读写单元组成，表示一片可操作空间
2. 管理： 人为的去操作一片空间的申请、使用和释放
3. 内存管理： 开发者主动申请空间、使用空间、释放空间
4. 管理流程： 申请--使用--释放


# 垃圾回收与常见GC算法
1. javascript 中内存管理是自动的
2. 对象不再被引用时时垃圾
3. 对象不能从根上访问到时时垃圾

# 可达对象
1. 可以访问到的对象就是可达对象（引用、作用域链）
2. 可达的标准就是从根出发是否能够被找到
3. JavaScript中的根就可以理解为全局变量对象

# GC
1. 是垃圾回收机制的简写
2. GC可以找到内存中的垃圾、并释放和回收空间

# 常见GC算法
1. 引用计数
    原理：
        - 核心思想： 设置引用数，判断当前引用数是否为0
        - 引用计数器
        - 引用关系改变时修改引用数字
        - 引用数字为0时立即回收
    优点：
        - 发现垃圾时立即回收
        - 最大限度减少程序暂停（程序即将占满空间gc就回清除空间）
    缺点：
        - 无法回收循环引用的对象
        - 时间开销大
        - 资源消耗较大（计数）

2. 标记清除
    原理：
        - 核心思想： 分标记和清除两个阶段完成
        - 遍历所有对象找标记活动对象
        - 遍历所有对象清除没有标记对象
        - 回收相应的空间
    优点：
        - 解决对象循环引用的问题
        - 不会立即回收垃圾对象
    缺点：
        - 空间碎片化

3. 标记整理
    原理：
        - 标记整理可以看作是标记清除的增强
        - 标记阶段的操作和标记清除一致
        - 清除阶段会先执行整理，移动对象位置
    优点：
        - 减少碎片化空间
    缺点
        - 不会立即回收垃圾对象

4. 分代回收


# 垃圾
1. 程序中不再需要使用的对象
2. 程序中不能再访问到的对象

# 认识V8
1. 采用即时编译
2. 内存设限（有上限 1.5G、800M）


# V8引擎的垃圾回收
1. 采用分代回收的思想
2. 内存分为新生代、老生代
3. 针对不同对象采用不同算法

# V8常用的GC算法
1. 分代回收
2. 空间复制
3. 标记清除
4. 标记整理
5. 标记增量


# V8如何回收新生代对象
1. V8内存空间一分为二
2. 小空间用于存储新生代对象（32M ｜ 16M）
3. 新生代指的是存活时间较短的对象
GC
4. 回收过程采用复制算法 + 标记整理
5. 新生代内存区分为二个等大小空间
6. 使用空间为From，空闲空间为To
7. 活动对象存储与From空间
8. 标记整理后将活动对象拷贝至To
9. From与To交换空间完成释放
10. 拷贝过程中可能出现晋升
11. 晋升就是将新生代对象移动至老生代
12. 一轮GC还存活的新生代需要晋升
13. To空间的使用率超过25%


# V8如何回收老生代对象
1. 老生代对象存放在右侧老生代区域
2. 64位操作系统1.4g，32操作系统700M
3. 老生代对象就是存活时间较长的对象（闭包，全局）
GC
4. 主要采用标记清除、标记整理、增量标记算法
5. 首先使用标记清除完成垃圾空间的回收
6. 采用标记整理进行空间优化
7. 采用增量标记进行效率优化

# 新生代与老生代对比
1. 新生代区域空间回收使用空间换时间
2. 老生代区域空间回收不适合复制算法（空间大费时间）

# 垃圾回收会阻塞JavaScript的执行




# Performance工具
1. GC的目的是为了实现空间的良性循环
2. 良性循环的基石是合理使用
3. 时刻关注才能确定是否合理
4. performance提供多种监控方式
5. 通过performance时刻监控内存


# 内存问题的外在表现（17）
1. 页面出现延迟加载或经常性暂停（GC频繁在执行）
2. 页面持续性出现糟糕的性能（内存膨胀：申请内存大于设备内存）
3. 页面的性能随时间延长越来越差（内存泄漏）


# 内存监控的几种方式

1. 内存泄露：内存使用持续升高
2. 内存膨胀：（在多数设备上都存在性能问题）
3. 频繁垃圾回收： 通过内存变化图进行分析

监控
4. 浏览器任务管理器
5. Timeline时序图记录
6. 堆快照查找分离dom
7. 判断是否存在频繁的垃圾回收

# 任务管理器监控内存（19）

# Timeline记录内存





