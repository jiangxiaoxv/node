
# 内存管理
1. 内存： 由可读写单元组成，表示一片可操作空间
2. 管理： 人为的去操作一片空间的申请、使用和释放
3. 内存管理： 开发者主动申请空间、使用空间、释放空间
4. 管理流程： 申请--使用--释放


# 垃圾回收与常见GC算法
1. javascript 中内存管理是自动的
2. 对象不再被引用时时垃圾
3. 对象不能从根上访问到时时垃圾

# 可达对象
1. 可以访问到的对象就是可达对象（引用、作用域链）
2. 可达的标准就是从根出发是否能够被找到
3. JavaScript中的根就可以理解为全局变量对象

# GC
1. 是垃圾回收机制的简写
2. GC可以找到内存中的垃圾、并释放和回收空间

# 常见GC算法
1. 引用计数
    原理：
        - 核心思想： 设置引用数，判断当前引用数是否为0
        - 引用计数器
        - 引用关系改变时修改引用数字
        - 引用数字为0时立即回收
    优点：
        - 发现垃圾时立即回收
        - 最大限度减少程序暂停（程序即将占满空间gc就回清除空间）
    缺点：
        - 无法回收循环引用的对象
        - 时间开销大
        - 资源消耗较大（计数）

2. 标记清除
    原理：
        - 核心思想： 分标记和清除两个阶段完成
        - 遍历所有对象找标记活动对象
        - 遍历所有对象清除没有标记对象
        - 回收相应的空间
    优点：
        - 解决对象循环引用的问题
        - 不会立即回收垃圾对象
    缺点：
        - 空间碎片化

3. 标记整理
    原理：
        - 标记整理可以看作是标记清除的增强
        - 标记阶段的操作和标记清除一致
        - 清除阶段会先执行整理，移动对象位置
    优点：
        - 减少碎片化空间
    缺点
        - 不会立即回收垃圾对象

4. 分代回收


# 垃圾
1. 程序中不再需要使用的对象
2. 程序中不能再访问到的对象

# 认识V8
1. 采用即时编译
2. 内存设限（有上限 1.5G、800M）


# V8引擎的垃圾回收
1. 采用分代回收的思想
2. 内存分为新生代、老生代
3. 针对不同对象采用不同算法

# V8常用的GC算法
1. 分代回收
2. 空间复制
3. 标记清除
4. 标记整理
5. 标记增量


# V8如何回收新生代对象
1. V8内存空间一分为二
2. 小空间用于存储新生代对象（32M ｜ 16M）
3. 新生代指的是存活时间较短的对象
GC
4. 回收过程采用复制算法 + 标记整理
5. 新生代内存区分为二个等大小空间
6. 使用空间为From，空闲空间为To
7. 活动对象存储与From空间
8. 标记整理后将活动对象拷贝至To
9. From与To交换空间完成释放
10. 拷贝过程中可能出现晋升
11. 晋升就是将新生代对象移动至老生代
12. 一轮GC还存活的新生代需要晋升
13. To空间的使用率超过25%


# V8如何回收老生代对象
1. 老生代对象存放在右侧老生代区域
2. 64位操作系统1.4g，32操作系统700M
3. 老生代对象就是存活时间较长的对象（闭包，全局）
GC
4. 主要采用标记清除、标记整理、增量标记算法
5. 首先使用标记清除完成垃圾空间的回收
6. 采用标记整理进行空间优化
7. 采用增量标记进行效率优化

# 新生代与老生代对比
1. 新生代区域空间回收使用空间换时间
2. 老生代区域空间回收不适合复制算法（空间大费时间）

# 垃圾回收会阻塞JavaScript的执行




# Performance工具
1. GC的目的是为了实现空间的良性循环
2. 良性循环的基石是合理使用
3. 时刻关注才能确定是否合理
4. performance提供多种监控方式
5. 通过performance时刻监控内存


# 内存问题的外在表现（17）
1. 页面出现延迟加载或经常性暂停（GC频繁在执行）
2. 页面持续性出现糟糕的性能（内存膨胀：申请内存大于设备内存）
3. 页面的性能随时间延长越来越差（内存泄漏）


# 内存监控的几种方式

1. 内存泄露：内存使用持续升高
2. 内存膨胀：（在多数设备上都存在性能问题）
3. 频繁垃圾回收： 通过内存变化图进行分析

监控
4. 浏览器任务管理器
5. Timeline时序图记录
6. 堆快照查找分离dom
7. 判断是否存在频繁的垃圾回收


# 堆快照查找分离DOM
1. 什么是分离DOM
   - 界面元素存活在DOM树上
   - 垃圾对象时的DOM节点
   - 分离状态的DOM节点

# 确定频繁的垃圾回收
1. timeline 中频繁的上升下降
2. 任务管理器中数据频繁的增加减少




# 任务管理器监控内存（19）

# Timeline记录内存



# V8引擎工作流程
1. scanner 成token
2. parser 是一个解析器
3. 预解析 
   - 跳过未被使用的代码
   - 不生成AST， 创建无变量引用和声明的scopes
   - 依据规范抛出特定错误
   - 解析速度更快
4. 全量解析
   - 解析被使用的代码
   - 生成AST
   - 构建具体scopes信息，变量引用、声明等
   - 抛出所有语法错误

5. Ignition 是V8提供的一个解释器

# 堆栈操作
1. VO（G）全局变量对象
2. GO 全局对象，是一个对象，会有一个内存的空间地址，不是VO


# 引用类堆栈处理处理(16进制地址)
var obj1 = {x: 100}
var obj2 = obj1

obj1.y = obj1 = {x: 200} // obj1.y = (obj1 = {x: 200})
console.log(obj1.y) // undefined
console.log(obj2) // {x: 100, y: {x: 200}}

# 函数堆栈处理
var arr = ['zce', 'alishi']
function foo(obj) {
    obj[0] = 'zoe'
    obj = ['xx']
    obj[1] = '大前端'
    console.log(obj)
}

foo(arr)
console.log(arr)
1. 函数执行时做的事情
   - 确定作用域连： 当前执行上下文，上级执行上下文
   - 确定this
   - 初始化arguments
   - 形参赋值
   - 变量提升
   - 执行代码

# 函数创建
1. 可以将函数名称看作是变量，存放在vo当中，同时它的值就是当前函数对应的
   内存地址
   函数本身也是一个对象，创建时会有一个内存地址，空间内存放的就是函数体代码


# 闭包堆栈处理

var a = 1
function foo() {
    var b = 2;
    return function(c) {
        console.log(c + b++) // 7, 13
    }
}
var f = foo()
f(5)
f(10)
闭包是执行上下文没有被释放


# 变量的局部话、缓存数据、减少访问层级
1. 减少声明和语句数（词法与语法）
2. 缓存数据（作用连查找）
3. 















