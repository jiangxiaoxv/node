# 函数式编程 FP
1. 函数式编程是编程范式之一，例如 面向过程、面向对象一样
2. 面向对象的思维方式：把现实世界中的事物抽象成程序世界中的类和对象，通过
   封装、继承和多态演示事物事件的联系
3. 函数式编程的思维方式：把现实世界的事物和事物之间的联系抽象到程序世界（对运算过程进行抽象）
   - 程序的本质：根据输入通过运算获得相应的输出，程序开发过程中会涉及很多输入和输出的函数
   - x -> f(联系、映射) ->y , y = f(x)
   - 函数式编程中的函数指的不是程序中的方法（方法），而是数学中函数
     即映射关系
   - 相同的输入始终要得到相同的输出（纯函数）
   - 函数式编程用来面熟数据（函数）之间的映射

# 函数是一等公民
1. 函数可以存储在变量中
2. 函数作为参数
3. 函数作为返回值

# 高阶函数
1. 可以把函数作为参数传递给另一个函数
2. 可以把函数另一个函数的返回结果


# 闭包
1. 闭包的本质：函数在执行的时候会放到一个执行栈上，当函数执行完毕之后
   会从执行栈移除，但是堆上的作用域成员因为被外部引用不能被释放，
   因此内部函数依然可以访问外部函数的成员 

# 纯函数
1. 纯函数：相同的输入永远会得到相同的输出
2. 纯函数的好处：
   - 对结果进行缓存，大任务缓存下来
   - 可测试
   - 并行处理
     纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数
3. 而且没有任何可观察的副作用
   副作用来源：变量、配置来源、数据库、用户输入

# 柯里化
1. 当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）
2. 然后返回一个新的函数接收剩余的参数，返回结果
3. 总结：
       - 柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数
         的新函数
       - 这是一种对函数参数的缓存
       - 让函数变得更灵活，让函数的粒度更小
       - 可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能

# 函数组合compose
1. 如果一函数要经过多个函数处理才能得到最终值，这个时候可以把中间
   过程的函数合并成一个函数
   - 函数就想是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果
   - 函数默认是从右到左执行
   
2. 函数的组合要满足结合律


# lodash 的fp模块

# Point Free
1. 不需要指明处理的数据
2. 只需要合成运算的过程
3. 需要定义一些辅助的基本运算函数


# Functor(函子)
1. 容器：包含值和值的变化关系（这个变形关系就是函数）
2. 函子：是一个特殊的容器，通过一个普通的对象来实现，该对象
        具有map方法，map方法可以运行一个函数对值进行处理（变形关系）
3. 总结：
       - 函数式编程的运算不直接操作值，而是由函子完成
       - 函子就是一个实现了map契约的对象
       - 我们可以把函子想象成一个盒子，这个盒子里封装了一个值
       - 想要处理盒子中的值，我们需要给盒子的map方法传递一个处理值
         的函数（纯函数），由这个函数对值进行处理
       - 最终map方法返回一个包含新值的盒子（函子）

# MayBe 函子

# Either函子
1. Either两者中的任何一个，类似于if... else ...的处理
2. 异常会让函数变得不纯，either函子可以用来做异常处理

# IO 函子
1. IO函子中的_value是一个函数，这里是吧函数作为值来处理
2. IO函子可以把不纯的动作存储到_value中，延迟执行这个不纯的操作（惰性执行），
   包装当前的操作纯
3. 把不纯的操作交给调用者来处理

# Task异步执行( npm i folktale)
1. 只提供了一些函数式处理的操作，如 compose,curry

# pointed 函子
1. pointed函子是实现了of静态方法的函子
2. of方法是为了避免使用new来创建对象，更深层的含义是of方法用来把
   值放到上下文context（把值放到容器中，使用map来处理值）

# Monad函子
1. ioFunctor.js



# 复习
# 函数的执行上下文
1. 全局执行上下文
2. 函数级执行上下文
3. eval执行上下文
4. 函数执行的阶段可以分两个：函数建立阶段、函数执行阶段
   - 函数建立阶段：当调用函数时，还没一偶执行函数内部的代码
     创建执行上下文
         fn.ExecutionContext = {
            this: {}
            scopeChains
            variableObject
         }
   - 函数执行阶段
     把变量对象转化为活动对象
         fn.ExecutionContext = {
            activationObject: // 函数中的arguments
            scopeChains: 父级作用域中的活动对象
            this: {}
         }
5. 函数没有执行，闭包就存在了

# 作用域

















