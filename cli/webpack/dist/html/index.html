// Module
var code = "<h1 id=\"webpack-初体验\">webpack 初体验</h1>\n<ol>\n<li>yarn init -y;  yarn add webpack webpack-cli -D  </li>\n<li>yarn webpack --version</li>\n<li>目录下的src/index.js是打包入口</li>\n<li>我们通过 file-loader 或者 url-loader 已经可以将 JS 或者 CSS 中用到的图片打包到指定目录中了，但是 file-loader 或者 url-loader 并不能将 HTML 中用到的图片打包到指定目录中，所以此时我们就需要再借助一个名称叫做 &quot;html-withimg-loader&quot; 的加载器来实现 HTML 中图片的打包</li>\n</ol>\n<h1 id=\"webpack5中配置file-loader打包后无法正常显示图片\">webpack5中配置file-loader打包后无法正常显示图片</h1>\n<ol>\n<li>在 webpack5 中 css-loader 会对 url() 处理为require(),旧的assets loader与新的assets loader冲突\n {\n test: /.(jpg|png|gif)$/,\n type: &#39;javascript/auto&#39;,\n use: {\n     loader: &#39;file-loader&#39;,\n     options: {\n     name: &#39;img/[name].[ext]&#39;,\n     esModule: false\n     },\n \n }</li>\n<li>webpack 5新处理方式，不实用file-loader\n {\n test: /.(png|jpe?g|ico|gif)$/i,\n type: &#39;asset/resource&#39;,\n generator: {\n     filename: &#39;images/[name]_[contenthash:8][ext]&#39;\n }\n },</li>\n</ol>\n<h1 id=\"data-urls\">Data URLs</h1>\n<ol>\n<li>当前url表示文件内容，不用发http请求</li>\n<li>{\n test: /.(png|jpe?g|ico|gif)$/i,\n type: &#39;asset&#39;, // asset和asset/resource的区别就是，后者只做拷贝，不能配置转base64。\n parser: {\n     dataUrlCondition: {\n         maxSize: 10 * 1024 // 10kb一下采用base64的dataURl\n     }\n },\n generator: {\n     filename: &#39;images/[name]_[contenthash:8][ext]&#39;\n }\n },</li>\n<li>{\n         test: /.(jpg|png|gif)$/,\n         type: &#39;javascript/auto&#39;,\n         use: {\n           loader: &#39;file-loader&#39;,\n           options: {\n             name: &#39;img/[name].[ext]&#39;,\n             esModule: false\n           },\n         },\n     }\nurl-loader 不满足条件内部会调用file-loader处理，所以webpack\n配置文件不需要单独再写一遍file-loader</li>\n</ol>\n<h1 id=\"loader分类\">Loader分类</h1>\n<ol>\n<li>编译转换类 css-loader</li>\n<li>文件操作类 url-loader</li>\n<li>代码检查类 eslint</li>\n</ol>\n<h1 id=\"babel\">Babel</h1>\n<ol>\n<li>yarn add babel-loader @babel/core @babel/preset-env</li>\n<li>webpack 只是打包工具，加载器可以用来编译转换代码</li>\n</ol>\n<h1 id=\"html-loader\">Html-loader</h1>\n<ol>\n<li>html-withimg-loader、html-loader 只会处理html的img，a标签不会被处理</li>\n<li><pre><code>     {   \n         test: /\\.(html|html)$/,\n         include: path.join(__dirname, &#39;src/html&#39;),\n         use: {\n             loader: &#39;html-loader&#39;,\n             options: {\n                 // attrs: [&#39;img:src&#39;, &#39;a:href&#39;] webpack 4的语法\n                 // esModule: false,\n                 sources: {\n                     list:[\n                         &quot;...&quot;,// 所有默认支持的标签和属性，这个一定要加上，不然就只会检测a标签了\n                         {\n                             tag:&quot;a&quot;,\n                             attribute: &#39;href&#39;,\n                             type: &#39;src&#39;\n                         }\n                     ]\n                 }\n             }\n         }\n     },\n</code></pre>\n</li>\n</ol>\n<h1 id=\"自己开发loader\">自己开发loader</h1>\n<ol>\n<li>处理markDown</li>\n<li>loader 是把源文件经过处理，返回标准的JavaScript代码，再传递给webpakc内部打包，\n所以自己写的loader返回的内容要是标准的JavaScript</li>\n<li>安装额外的markDown模块解析工具\nyarn add marked -D</li>\n<li>对marked处理后的html进行转化 \nhtml-loader 处理其html\n{\n test: /.md$/,\n use: [\n     {\n         loader: &#39;html-loader&#39;,\n     },\n     {\n         loader: resolve(&#39;./src/myLoader/markdown-loader.js&#39;),\n     },\n ]\n },</li>\n</ol>\n";
// Exports
export default code;